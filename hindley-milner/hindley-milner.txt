-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Toy Hindley-Milner implementation
--   
--   Toy Hindley-Milner implementation
@package hindley-milner
@version 0.0.2.1


-- | This module implements parsers for our language. It is the first step
--   in the interpretation process (followed by type inference in
--   <a>Infer</a>, and finally evaluation in <a>Eval</a>). More
--   specifically, this module is responsible for transforming <a>Text</a>
--   into expressions (<a>Expr</a>).
--   
--   Examples:
--   
--   <ul>
--   <li><i>Factorial 10</i> <tt>let fact n = if (eq n 0) 1 (mul n (fact
--   (add n (neg 1)))) in fact 10</tt></li>
--   </ul>
module HindleyMilner.Parse

-- | An expression.
data Expr

-- | A variable (e.g. <tt>abc</tt>).
VarE :: Iden -> Expr

-- | A literal value.
LitE :: Lit -> Expr

-- | An application.
AppE :: Expr -> Expr -> Expr

-- | A lambda.
LambdaE :: Iden -> Expr -> Expr

-- | A let binding (e.g. <tt>let f x = add x 2 in f 1</tt>).
LetE :: Binding -> Expr -> Expr

-- | An identifier (e.g. variable name).
type Iden = Text

-- | A literal value.
data Lit
DoubleL :: Double -> Lit
StringL :: Text -> Lit
BoolL :: Bool -> Lit
displayLit :: Lit -> Text

-- | A bound identifier.
data Binding
Binding :: Iden -> [Iden] -> Expr -> Binding

-- | Bound reference.
[bindingIden] :: Binding -> Iden

-- | Arguments (if the binding is a lambda).
[bindingArgs] :: Binding -> [Iden]

-- | Bound expression.
[bindingExpr] :: Binding -> Expr

-- | A parser specialized to our implementation.
type Parser a = Parsec Void Text a

-- | Returns an expression parser.
--   
--   Five types of expressions are supported:
--   
--   <ul>
--   <li><i>Identifiers:</i> <tt>IDEN</tt>, must start with a lower-case
--   letter then alpha-numeric characters</li>
--   <li><i>Literals:</i> <tt>LIT</tt> (numbers, <tt>True</tt>,
--   <tt>False</tt>)</li>
--   <li><i>Function applications:</i> <tt>FN_IDEN ARG_IDEN</tt></li>
--   <li><i>Bindings:</i> <tt>let BINDING in EXPR</tt></li>
--   <li><i>Groups:</i> <tt>(EXPR)</tt></li>
--   </ul>
exprParser :: Parser Expr

-- | Returns a parser for bindings (the subsection between <tt>let</tt> and
--   <tt>in</tt>). This parser is exported to allow extending the built-in
--   environment.
--   
--   The syntax is <tt>REF_IDEN [ARG_IDEN...] = BODY_EXPR</tt> where
--   <tt>REF_IDEN</tt> is the identifier of the binding, <tt>ARG_IDEN</tt>
--   is the identifier of an argument (there can be 0 or more), and
--   <tt>EXPR_BODY</tt> is the body of the binding.
bindingParser :: Parser Binding

-- | Error thrown during parsing.
type ParsingError = ParseErrorBundle Text Void

-- | Pretty-prints a parsing error.
displayParsingError :: ParsingError -> Text
instance GHC.Show.Show HindleyMilner.Parse.Expr
instance GHC.Classes.Ord HindleyMilner.Parse.Expr
instance GHC.Classes.Eq HindleyMilner.Parse.Expr
instance GHC.Show.Show HindleyMilner.Parse.Binding
instance GHC.Classes.Ord HindleyMilner.Parse.Binding
instance GHC.Classes.Eq HindleyMilner.Parse.Binding
instance GHC.Show.Show HindleyMilner.Parse.Lit
instance GHC.Classes.Ord HindleyMilner.Parse.Lit
instance GHC.Classes.Eq HindleyMilner.Parse.Lit


-- | This module implements expression typing. It is the second step in the
--   interpretation process (after parsing in <a>Parse</a> and before
--   evaluation in <a>Eval</a>).
--   
--   Type inference is done in two phases:
--   
--   <ul>
--   <li><i>Discovery</i>, where we walk the AST, assign fresh type
--   variables where appropriate, and emit constraints.</li>
--   <li><i>Unification</i>, where we unify all types using the emitted
--   constraints and output the resulting expression's type.</li>
--   </ul>
--   
--   Note that let bindings are generalized:
--   
--   <pre>
--   let f x = x in if (f True) (f 1) 0 -- OK.
--   let g f = if (f True) (f 1) 0 in let f x = x in g f -- Not OK ("generalized" once in @g f@).
--   </pre>
module HindleyMilner.Infer

-- | The type of an expression.
data Type

-- | A type variable.
VarT :: TypeVar -> Type

-- | A type constant (e.g. doubles or strings).
ConstT :: Text -> Type

-- | A function type.
ArrowT :: Type -> Type -> Type
infixr 5 `ArrowT`

-- | Pretty-prints a type. All type variables are represented as
--   <tt>$N</tt>, numbered starting from 1 in the order they are displayed
--   left to right (so <tt>$1</tt>, <tt>$2</tt>, ...).
displayType :: Type -> Text

-- | A type variable.
newtype TypeVar
TypeVar :: Int -> TypeVar
[unVar] :: TypeVar -> Int
boolType :: Type
doubleType :: Type
stringType :: Type

-- | Infer an expression's type.
infer :: Expr -> TypeEnv -> Either TypeError Type

-- | All known type signatures. We store signatures rather than types to be
--   able to generalize them appropriately at usage sites (i.e. generalize
--   let bindings but keep function arguments as-is).
data TypeEnv

-- | Creates a singleton <a>TypeEnv</a> for the given type. The binding is
--   as polymorphic as possible.
boundTo :: Type -> Iden -> TypeEnv

-- | Extracts a type from the environment.
lookupType :: Iden -> TypeEnv -> Maybe Type

-- | Error thrown when an expression is ill-typed.
data TypeError

-- | Failed to unify a type which occurs in an arrow type.
InfiniteType :: Type -> Type -> TypeError

-- | Failed to match two types.
UnificationFailure :: Type -> Type -> TypeError

-- | Encountered an undefined identifier.
UnboundVariable :: Iden -> TypeError

-- | Pretty-prints a type error.
displayTypeError :: TypeError -> Text
instance GHC.Classes.Ord HindleyMilner.Infer.Constraint
instance GHC.Classes.Eq HindleyMilner.Infer.Constraint
instance GHC.Base.Semigroup HindleyMilner.Infer.TypeEnv
instance GHC.Base.Monoid HindleyMilner.Infer.TypeEnv
instance GHC.Classes.Ord HindleyMilner.Infer.Type
instance GHC.Classes.Eq HindleyMilner.Infer.Type
instance GHC.Classes.Ord HindleyMilner.Infer.TypeVar
instance GHC.Classes.Eq HindleyMilner.Infer.TypeVar


-- | This module implements expression evaluation.
module HindleyMilner.Eval

-- | An evaluation environment.
data Env

-- | Looks up an identifier in the environment.
envLookup :: Iden -> Env -> Maybe (Type, Value)

-- | Evaluates an expression in the given environment.
eval :: Expr -> Env -> Either TypeError (Type, Value)

-- | The result of evaluating an expression.
data Value

-- | A literal value.
LitV :: Lit -> Value

-- | A closure.
ClosureV :: (Value -> Value) -> Value

-- | Something went wrong.
UndefinedV :: Value

-- | Adds a binding to an existing environment.
bind :: Binding -> Env -> Either TypeError Env

-- | Generates an environment with a single identifier bound. The type and
--   value must match, no checks are performed.
--   
--   This is useful in combination to add "built-in" functionality. For
--   example, to generate an environment with a <a>sin</a> operation, we
--   could do something similar to:
--   
--   <pre>
--   env = unsafeEnv "sin" (tp, ClosureV fn) where
--     tp = doubleType -&gt; doubleType
--     fn (LitV (DoubleL d)) = LitV $ DoubleL $ sin d
--     fn _ = UndefinedV
--   </pre>
unsafeEnv :: Iden -> (Type, Value) -> Env
instance GHC.Base.Semigroup HindleyMilner.Eval.Env
instance GHC.Base.Monoid HindleyMilner.Eval.Env


-- | This module exposes a higher-level API to run computations in our toy
--   implementation of the Hindley-Milner type system. It also provides
--   various common built-in functions via <a>defaultEnv</a>.
--   
--   The underlying implementation is split into three modules:
--   
--   <ul>
--   <li><a>HindleyMilner.Parse</a>, responsible for parsing text into
--   expressions</li>
--   <li><a>HindleyMilner.Infer</a>, responsible for inferring the type of
--   each expression</li>
--   <li><a>HindleyMilner.Eval</a>, responsible for evaluating well-typed
--   expressions. This module also provides utilities for extending the
--   implementation with new built-ins.</li>
--   </ul>
module HindleyMilner

-- | Interpret a command.
--   
--   For example, the following will compute the value six:
--   
--   <pre>
--   result = flip evalState defaultEnv $ do
--     interpret "x = 1"
--     interpret "y = add x 2" -- Assign y = x + 2 = 3.
--     interpret "mul x y" -- Return x * y = 6.
--   </pre>
interpret :: MonadState Env m => Text -> m Result

-- | The result of interpreting a command.
data Result

-- | A pure value.
Computation :: Value -> Result

-- | A binding was added to the environment.
BoundIdentifier :: Iden -> Type -> Result

-- | The command could not be parsed.
InvalidSyntax :: ParsingError -> Result

-- | The command was parsed but did not have a valid type.
InvalidType :: TypeError -> Result

-- | An evaluation environment.
data Env

-- | A default environment with bindings for common functionality:
--   
--   <ul>
--   <li>Numeric operations: <tt>add</tt>, <tt>mul</tt>, <tt>neg</tt>,
--   ...</li>
--   <li>Conditional and predicates: <tt>if</tt>, <tt>eq</tt>, <tt>gt</tt>,
--   <tt>lt</tt>, ...</li>
--   </ul>
defaultEnv :: Env

-- | Looks up an identifier in the environment.
envLookup :: Iden -> Env -> Maybe (Type, Value)

-- | The type of an expression.
data Type

-- | A type variable.
VarT :: TypeVar -> Type

-- | A type constant (e.g. doubles or strings).
ConstT :: Text -> Type

-- | A function type.
ArrowT :: Type -> Type -> Type
infixr 5 `ArrowT`

-- | A type variable.
data TypeVar

-- | Pretty-prints a type. All type variables are represented as
--   <tt>$N</tt>, numbered starting from 1 in the order they are displayed
--   left to right (so <tt>$1</tt>, <tt>$2</tt>, ...).
displayType :: Type -> Text

-- | The result of evaluating an expression.
data Value

-- | A literal value.
LitV :: Lit -> Value

-- | A closure.
ClosureV :: (Value -> Value) -> Value

-- | Something went wrong.
UndefinedV :: Value

-- | A literal value.
data Lit
DoubleL :: Double -> Lit
StringL :: Text -> Lit
BoolL :: Bool -> Lit
displayLit :: Lit -> Text

-- | Error thrown during parsing.
type ParsingError = ParseErrorBundle Text Void

-- | Pretty-prints a parsing error.
displayParsingError :: ParsingError -> Text

-- | Error thrown when an expression is ill-typed.
data TypeError

-- | Failed to unify a type which occurs in an arrow type.
InfiniteType :: Type -> Type -> TypeError

-- | Failed to match two types.
UnificationFailure :: Type -> Type -> TypeError

-- | Encountered an undefined identifier.
UnboundVariable :: Iden -> TypeError

-- | Pretty-prints a type error.
displayTypeError :: TypeError -> Text
